def gcd(numerator, denominator):    """    find gcd between two values    """    if numerator == 0 or denominator == 0:        return 0    while numerator != denominator:        if numerator > denominator:            numerator -= denominator        else:            denominator -= numerator    return numeratorclass Fraction:    """A fraction with a numerator and denominator and arithmetic operations.    Fractions are always stored in proper form, without common factors in     numerator and denominator, and denominator >= 0.    Since Fractions are stored in proper form, each value has a    unique representation, e.g. 4/5, 24/30, and -20/-25 have the same    internal representation.    """        def __init__(self, numerator, denominator=1):        """Initialize a new fraction with the given numerator           and denominator (default 1).        """        self.gcd = gcd(abs(numerator), abs(denominator))        if self.gcd == 0:            self.numerator = numerator            self.denominator = denominator        else:            self.numerator = int(numerator/self.gcd)            self.denominator = int(denominator/self.gcd)            if self.denominator < 0:                self.denominator = abs(self.denominator)                self.numerator = -1*self.numerator    def __add__(self, frac):        """Return the sum of two fractions as a new fraction.           Use the standard formula  a/b + c/d = (ad+bc)/(b*d)        """        return Fraction((self.numerator * frac.denominator + self.denominator * frac.numerator),                        self.denominator * frac.denominator)    # TODO write __mul__ and __str__.  Verify __eq__ works with your code.    # Optional have fun and overload other operators such as    def __str__(self):        """        Return string as fraction form        """        if self.numerator == 0:            return str(self.numerator)        elif self.denominator == 1:            return str(self.numerator)        else:            return str(self.numerator)+"/"+str(self.denominator)    # __mul__ for f*g    def __mul__(self, frac):        """Return the multiply of two fractions as a new fraction."""        return Fraction(self.numerator*frac.numerator, self.denominator*frac.denominator)    # __sub__ for f-g    def __sub__(self, frac):        """Return the minus of two fractions as a new fraction."""        return Fraction((self.numerator * frac.denominator - self.denominator * frac.numerator),                        self.denominator * frac.denominator)    # __gt__  for f > g    def __gt__(self, frac):        """return the comparing between two fractions as boolean"""        own_result = self.numerator/self.denominator        other_result = frac.numerator/frac.denominator        return own_result > other_result    # __neg__ for -f (negation)    def __neg__(self):        """return the negative value of fraction"""        neg_numerator = self.numerator*-1        if neg_numerator == 0:            return str(neg_numerator)        elif self.denominator == 1:            return str(neg_numerator)        else:            return str(neg_numerator) + "/" + str(self.denominator)    def __eq__(self, frac):        """            Two fractions are equal if they have the same value.           Fractions are stored in proper form so the internal representation           is unique (3/6 is same as 1/2).        """        return self.numerator == frac.numerator and self.denominator == frac.denominator